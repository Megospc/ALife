<!DOCTYPE html>
<html>
<head>
  <title>ALife - Record</title>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <div class="headdiv">
    <h1 id="header" class="header"></h1>
    <a id="mainpage"></a>
  </div>
  <div id="select">
    <input type="file" id="fileinput" style="display: none" onchange="readFile(this.files[0])">
  </div>
  <div id="main"></div>
</body>
</html>
<script src="strings.js"></script>
<script src="utils.js"></script>
<script src="style.js"></script>
<script src="interface.js"></script>
<script src="main.js"></script>
<script src="render.js"></script>
<script src="reader.js"></script>
<script>
  function readFile(file) {
    const reader = new FileReader();
    
    reader.readAsArrayBuffer(file);
    
    reader.onload = () => parse(reader.result);
    reader.onerror = () => alert(strings.readFileFailed);
  }
  
  const { language, strings } = getWindowStrings(languagesStrings);
  
  const select = new Element("select");
  const main = new Element("main").hide();
  
  new Element("header").attr("textContent", strings.recordHeader);
  new Element("mainpage")
    .attr("textContent", strings.toMainpage)
    .attr("href", "index.html?lang="+language);
  
  new ButtonElement(strings.setupSelect, () => document.getElementById("fileinput").click()).to(select);
  
  setupLanguageChanger(new DivElement().to(select), strings, language);
  
  var obj, settings, simulation, interface, interval;
  
  function parse(buffer) {
    const u8 = new Uint8Array(buffer);
    
    const reader = createReader(u8);
    
    const simulation = reader.simulation;
    
    const targetsize = 
      simulation.width == 800 ? 1600:
      simulation.width == 1800 ? 1800:1200;
    
    interface = setupInterface("main", simulation, {
      strings,
      language,
      targetsize,
      
      bottomstats: false,
      
      framereset: function() {
        reader.reset();
        
        readFrame(reader);
      }
    });
    
    renderer = createRenderer(interface, simulation, style);
    
    let lastTime = performance.now();
    let lastRenderedFrame = -1;
    let lastRenderedZoom = -1;
    let lastHandleFrame = 0;
    let frame = 0;
    
    setInterval(() => {
      const handlestart = performance.now();
      
      if (!reader.isEnd && !interface.paused && (frame-lastHandleFrame) >= (20-interface.speed.value)) {
        readFrame(reader);
        
        lastHandleFrame = frame;
      }
      
      const handletime = performance.now()-handlestart;
      
      const renderstart = performance.now();
      
      if (interface.renderoff.value) interface.canvasdiv.hide();
      else {
        const zoom = interface.getZoom();
        
        if (interface.changed || lastRenderedFrame !== simulation.frame || lastRenderedZoom !== zoom) {
          render(renderer, {
            nopictures: true
          });
          
          lastRenderedFrame = simulation.frame;
          lastRenderedZoom = zoom;
          
          interface.changed = false;
        }
        
        interface.canvasdiv.show();
      }
      
      const rendertime = performance.now()-renderstart;
      
      interface.frame.value = simulation.frame;
      interface.population.value = simulation.population;
      
      interface.handletime.value = Math.floor(handletime);
      interface.rendertime.value = Math.floor(rendertime);
      
      interface.performance.value = performanceString(simulation.width*simulation.height, handletime);
      
      frame++;
      
      if (frame%10 === 0) {
        const time = performance.now();
        
        interface.fps.value = (1000/(time-lastTime)*10).toFixed(1);
        
        lastTime = time;
      }
    }, 15);
    
    select.hide();
    main.show();
  }
  
  function start() {
    if (interval) {
      clearInterval(interval);
      
      main.attr("innerHTML", "");
    }
    
    const size = +settings.size.value;
    
    const reqmem = (size**2)*512;
    
    const gib = 2**30;
    
    const devmem = (navigator.deviceMemory ?? 0.5)*gib/2;
    
    if (devmem <= reqmem || reqmem >= gib) if (!confirm(strings.memoryAsk(reqmem))) return;
    
    simulation = createSimulation(size, size, {
      ...obj.consts,
      mutationChance: 0
    }, settings.seed.value);
    
    const methods = simulation.methods;
    
    const i = methods.posIndex(Math.floor(size/2), Math.floor(size/2));
    
    methods.putNewCellIndex(2, i);
    
    simulation.energy[i] = 20000;
    simulation.angle[i] = 0;
    
    simulation.current[i] = 0;
    simulation.curprog[i] = +settings.prog.value;
    simulation.clan[i] = 0;
    
    const genomeLength = simulation.consts.genomeWidth*simulation.consts.genomeHeight;
    
    for (let j = 0; j < genomeLength; j++) simulation.genome[i*genomeLength+j] = obj.genome[j];
  
    const charge = settings.resources.value;
    const organic = charge/simulation.consts.organicCost;
    
    for (let i = 0; i < simulation.organic.length; i++) simulation.organic[i] = organic;
    for (let i = 0; i < simulation.charge.length; i++) simulation.charge[i] = charge;
    
    simulation.sun = settings.sun.value;
    
    
    
    
    
    interface.pause.onclick();
    
    renderer = createRenderer(interface, simulation, style);
  
    interval = startWindow([], [], interface, simulation, renderer);
    
    main.show();
  }
  
  if (sessionStorage.getItem("alife-save")) {
    parseJSON(sessionStorage.getItem("alife-save"));
    
    sessionStorage.setItem("alife-save", "");
  }
  /*
  const simulation = createSimulation(300, 300, {}, generateRandomSeed());
  
  const interface = setupInterface("main", simulation, {
    strings,
    targetsize: 1200
  });
  
  const renderer = createRenderer(interface, simulation, style);
  
  const methods = simulation.methods;
  
  for (let i = 0, clan = 0; i < simulation.type.length; i++) {
    if (!methods.chance(1/9)) continue;
    
    methods.putNewCellIndex(2, i);
    
    simulation.energy[i] = 20000;
    simulation.angle[i] = methods.randomInt(4);
    
    simulation.current[i] = 0;
    simulation.curprog[i] = 0;
    simulation.clan[i] = clan++;
    
    methods.copyGenome(i);
  }
  
  const charge = 10000;
  const organic = 50;
  
  for (let i = 0; i < simulation.organic.length; i++) simulation.organic[i] = organic;
  for (let i = 0; i < simulation.charge.length; i++) simulation.charge[i] = charge;
  
  simulation.sun = 500;
  
  setupLanguageChanger(new DivElement().to(main), strings, language);
  
  startWindow([], [], interface, simulation, renderer);
  
  function start() {
    
  }*/
</script>